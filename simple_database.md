# Building a Simple Database

Following are the questions, this project will try to solve:

* What format does data saved in? (in memory and on disk)
* When does the data from memory to disk ?
* Why can there be only one primary key in a table ?
* How does rolling back a transaction work ?
* How are indexes formatted ?
* When and how does a full table scan happen ?
* What format a prepared statement is saved in ?

So, in other words, how a database works?

To figure this out, I'm going to write a database from scratch. It's modeled off sqlite just have some minimal features


## Sqlite:

You can visit [sqlite internals](https://www.sqlite.org/arch.html) to know how the internal works. In summary it's from top to down like this:

* Tokenizer
* Parser
* Code Generator
* Virtual Machine
* B-Tree
* Pager
* OS Interface

Top 3 can be considered as **frontend** while rest 4 as **backend**. The input to the front-end is SQL query, the output is sqlite virtual machine bytecode(compiled program operating on database).

The **virtual machine** takes bytecode generated by the front-end as instructions. It can perform operatrions on one or more tables or indexes, each of which is stored in B-Tree data structure. The vm can be considered as big switch statement on the type of bytecode instruction.

Each **B-tree** consists of many nodes. Each node is one page in length. The B-Tree can retrieve a page from disk and save it back to disk by issuing commands to the pager.

The **pager** recieves commands to read and write pages of data. Responsible for read/write in database file at appropriate offsets. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written by to disk.

The **os interface** is the layer that differs depending on which operating system sqlite was compiled for

## Making a Simple DB REPL:

Sqlite command-line repl in essence is just a read-execute-print loop.

You can find the code for [REPL](~/Documents/nc/simple_database/repl) in the link. All the comments will help you in understanding the code.


## Simplest SQL compiler and Virtual Machine

The `frontend` of sqlite is a SQL compiler that parses a string and outputs an internal representation called bytecode.

![SQLite Architecture](https://www.sqlite.org/images/arch2.gif)

The bytecode is passed to virtual machine which executes it

Breaking things into these two steps have couple of advantages:

* Reduces the complexity of each part(e.g., virtual machine does not worry about syntax erro)
* Allows compiling common queries once and caching the bytecode for improved performance

Code for REPL with the feel of simplest implementation of sql compiler and virtual machine abstraction is provided: [REPL2](~/Documents/nc/simple_database/repl2)


## In-Memory, Append-Only, Single-Table Database:

At start, there will be some certain limitations like:
* it'll support only two operations: inserting a row and printing all rows
* reside only in memory(no persistance to disk)
* support a single, hard-coded table

Our hard-coded table will store details of a models of car company and will look like this:

| column             | type         |
| :---:              | :---:        |
| sl_no          | int          |
| manufacturing_year | int          |
| company_name       | varchar(32)  |
| model_name         | varchar(128) |
| horsepower         | int          |

Even though, this is a simple schema, but it gets us to support multiple data types and multiple sizes of data types.

Our `insert` statements are now going to look like this:
```
insert 1 1969 Dodge Charger 700
```

For storing data, we'll start with something simpler at this moment. Like sqlite uses B-Tree for fast lookups of data for insertion and deletion, we'll arrange the pages(group of rows) as an array. Here's what to do:
* store rows in block of memory called pages
* Each page stores as many rows as it can fit
* Rows are serialized into a compact representation with each page
* Pages are only allocated as needed
* Keep a fixed-size array of pointers to pages

## Testing && fixing:

Following are the things which were done to test and fix existing code:

1. fixed length(bytes) for company name and model name
2. Tested of how much rows of data can be inserted in a table.
3. checks for string length in entered query and gives output accordingly

Test script written by me as `test.py`, `test2.py` and `test3.py`

## Making Change Persistence:

To make persistence we are going to save entire records to a db file. To add persistence, we have to simply write those blocks of memory(which we set already by serializing rows into page-sized memory blocks) into a file and read it back next time the program starts.

For this as previous, we are going to make an abstraction as `Pager`. We'll ask the pager for page number x, and the pager will give us back a block of memory. It'll first look in its cache and on a cache-miss, it copies data from disk into memory(through db file).

So, up until now, our _interface_ is `repl` and as _SQL Command Processor_ we have `prepare_statement()` for it and as for abstraction as Virtual Machine we have `execute_statement()` for it. And `Table` is working as of _B-Tree_(will updated soon) and now on to the _Pager_ which will be our new pager object.
